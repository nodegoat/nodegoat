<?php

/**
 * nodegoat - web-based data management, network analysis & visualisation environment.
 * Copyright (C) 2024 LAB1100.
 * 
 * nodegoat runs on 1100CC (http://lab1100.com/1100cc).
 * 
 * See http://nodegoat.net/release for the latest version of nodegoat and its license.
 */

class IngestTypeObjectsFile extends IngestTypeObjects {
	
	public static $arr_source_delimiters = [',', "\t", ';'];
	public static $arr_source_enclosures = ['"', '\''];
		
	public static function convertSource($arr_file, $arr_filter = false, $num_limit = false) {

		$path = $arr_file['tmp_name'];
		
		list($str_delimiter, $str_enclosure) = static::getFileDelimiterEnclosure($path);
		
		$file_source = fopen($path, 'r');
		
		if ($file_source === false) {
			return false;
		}
		
		resourceSkipBOM($file_source);
		
		$stream = new StreamJSONOutput();
		
		$arr_output = [$stream->getStream('', '')];
		
		$stream->open($arr_output);

		$count_rows = 0;
		$arr_row = fgetcsv($file_source, 0, $str_delimiter, $str_enclosure, CSV_ESCAPE);
		
		$num_columns = count($arr_row);
		$arr_column_labels = $arr_row;
		
		$count_rows++;
		$arr_row = fgetcsv($file_source, 0, $str_delimiter, $str_enclosure, CSV_ESCAPE);
		
		while ($arr_row !== false) {

			if ($num_limit !== false && $count_rows > $num_limit) {
				
				Labels::setVariable('limit', $num_limit);
				error(getLabel('msg_import_limit_exceeded'));
			} else {
				
				$arr = [];
			
				for ($count_columns = 0; $count_columns < $num_columns; $count_columns++) {
					
					$value = $arr_row[$count_columns];
					
					if (!mb_check_encoding($value, 'UTF-8')) {
						$value = mb_convert_encoding($value, 'UTF-8');
					}
					
					$str_label = $arr_column_labels[$count_columns];
					
					$arr[$str_label] = $value;
				}
				
				$stream->stream([$arr]);
			}

			$count_rows++;
			$arr_row = fgetcsv($file_source, 0, $str_delimiter, $str_enclosure, CSV_ESCAPE);
		}
				
		fclose($file_source);

		$num_objects = ($count_rows - 1); // -1 for the heading
		
		if (!$num_objects) {
			return false;
		}

		$file_new = $stream->close();

		// Overwrite source
		file_put_contents($path, $file_new);
		
		fclose($file_new);
		
		$arr_file['type'] = 'application/json';
		
		return ['file' => $arr_file, 'num_objects' => $num_objects];
	}
	
	protected static function getFileDelimiterEnclosure($path) {

		$arr_delimiters_found = [];
		$num_parse = 100;
		
		$str_delimiter = static::$arr_source_delimiters[0];
		$str_enclosure = static::$arr_source_enclosures[0];

		if (($file = fopen($path, 'r')) !== false) {

			foreach (static::$arr_source_delimiters as $str_test_delimiter) {
						
				$arr_delimiters_found[$str_test_delimiter] = [];
					
				foreach (static::$arr_source_enclosures as $str_test_enclosure) {
	
					rewind($file);
					$i = 0;	
					$num_pos_previous = 0;
					
					while (($arr_line = fgetcsv($file, 0, $str_test_delimiter, $str_test_enclosure, CSV_ESCAPE)) !== false && $i < $num_parse) {
							
						$i++;
						
						$arr_delimiters_found[$str_test_delimiter]['enclosures'][$str_test_enclosure]['count'][$i] = count($arr_line);

						$num_pos = ftell($file);
						fseek($file, $num_pos_previous);
						$str_line = fread($file, $num_pos);

						if (count($arr_line) == 1) {

							if (strpos($str_line, $str_test_enclosure) === 0 && strpos($str_line, $str_test_enclosure.PHP_EOL) !== false) {
							
								$arr_delimiters_found[$str_test_delimiter]['enclosures_found'][$str_test_enclosure]['count'][$i] = 1;
							}
						} else {

							if (strpos($str_line, $str_test_delimiter.$str_test_enclosure) !== false || strpos($str_line, $str_test_enclosure.$str_test_delimiter) !== false) {
								
								$arr_delimiters_found[$str_test_delimiter]['enclosures_found'][$str_test_enclosure]['count'][$i] = count($arr_line);
							} 							
						}
						
						fseek($file, $num_pos);
						$num_pos_previous = $num_pos;
					}
				}
			}
			
			fclose($file);
		}

		if ($arr_delimiters_found) {
			
			$num_score = 0;
		
			// Check if multiple rows have been generated by one delimiter and whether these rows have equal amounts of columns using either single or double quotes.
			
			foreach ($arr_delimiters_found as $str_check_delimiter => $arr_results) {
				
				$num_count_delimiter = 0;
				
				foreach ($arr_results['enclosures'] as $str_check_enclosure => $arr_enclosure) {
					
					if (count(array_unique($arr_enclosure['count'])) != 1) {
						continue;
					}
					
					$num_rows = count($arr_enclosure['count']);
					$num_count_delimiter = ($num_rows * end($arr_enclosure['count']));
				}
				
				if (!$arr_results['enclosures_found']) { // Delimiter has been found, but no enclosures were set. Use default/last found enclosure.
					$arr_results['enclosures_found'] = [$str_enclosure => ['count' => [1]]];
				}

				foreach ($arr_results['enclosures_found'] as $str_check_enclosure => $arr_enclosure_found) {
					
					if (count(array_unique($arr_enclosure_found['count'])) != 1) {
						continue;
					}
					
					$num_rows = count($arr_enclosure_found['count']);
					$num_count_enclosure = ($num_rows * end($arr_enclosure_found['count']));

					if (($num_count_enclosure * $num_count_delimiter) > $num_score) { // Multiply both enclosure scores to get best overall score
					
						$num_score = ($num_count_enclosure * $num_count_delimiter);
						
						$str_delimiter = $str_check_delimiter;
						$str_enclosure = $str_check_enclosure;
					}
				}
			}
		}

		return [$str_delimiter, $str_enclosure];
	}
	
	public static function checkTemplateSourceCompatibility($arr_template, $arr_source) {
			
		if (!$arr_source || !$arr_template['pointers']) {
			return false;
		}
		
		$import = new IngestTypeObjectsFile(false);
		$import->setTemplate($arr_template['pointers'], $arr_template['mode']);
		$import->setSource(DIR_HOME_TYPE_IMPORT.$arr_source['filename']);
		
		$arr_row = $import->getPointerData(0);
		
		$count_pointers = 0;
		
		foreach ($arr_template['pointers'] as $type => $arr_type_pointers) {
			
			if (!$arr_type_pointers) {
				continue;
			}
			
			if ($type == 'filter_object_identifier' || $type == 'filter_object_sub_identifier') {
				$arr_type_pointers = [$arr_type_pointers];
			}
			
			foreach ($arr_type_pointers as $arr_pointer) {
				
				if ($arr_row[$arr_pointer['pointer_heading']]) {
					$count_pointers++;
				}
			}
		}
		
		return $count_pointers;
	}
}
